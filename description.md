## Задача

Решается задача регрессии страховой выплаты на датасете Ethiopian Vehicle Insurance Data.

## Метод получения данных

Данные получаются батчами, размер которых конфигурируется в файле `config.json` из двух файлов. На каждый запрос выбирается случайный из этих двух файлов для эмуляции множественных источников. Батчи сохраняются в `data/batches`, логика работы с ними организуется через разделяемое между компонентами пайплайна состояние, хранимое в файле `config.json`.

## Оценка качества данных

Качество данных на настоящий момент оценивается по следующим метрикам: доля пропущенных значений в батчах и в данных в целом, дифференциальная энтропия распределения каждого из категориальных признаков в батчах и во всех данных.

## Модели

На каждой итерации запуска `update mode` берется три линейных модели из `sklearn`: `PassiveAggresiveRegressor`, `MLPRegressor`, `SGDRegressor`. На каждой из них с полученным батчем запускается `partial_fit`. На каждой итерации из трех моделей выбирается лучшая метрика (`MSELoss`), полученная на валидационном подмножестве и лучшая модель записывается в `models/best_model.pkl`. Версии моделей также хранятся в директории `models` для адаптации на каждом вызове `update`. Логика работы с моделями так же организуется через `config.json`.

## Предобработка признаков

На данный момент из множества признаков выбирается подмножество из всех числовых признаков `(PREMIUM, INSURED_VALUE)` и из категориальных `"SEX", "EFFECTIVE_YR", "INSR_TYPE", "SEATS_NUM","CARRYING_CAPACITY", "TYPE_VEHICLE"`.

На основании признаков `INSR_BEGIN`, `INSR_END` строится признак `DURATION`, равный разности этих дат в днях.

На основании признака `CLAIM_PAID` (в котором пропуск означает отсутствие выплаты) строится признак `HAS_CLAIM`, равный нулю в случае отсутствия и единице в случае наличия выплаты. При режиме `inference` этот признак пока выставляется в единицу.

Остальные категориальные признаки кодируются по первому батчу с помощью обучаемого на нем `OneHotEncoder`, игнорирующего не встреченные ранее категории. 

Автор не видит, при специфике задачи и фиксации размерности входных векторов при инициализации модели (в силу итеративного обучения), другого, более адекватного способа работать с признаками.

В качестве некоего компромисса, можно выбрать достаточно большой размер первого считываемого батча, чтобы в обученный `encoder` попало больше уникальных значений.
